import sys
import json
from typing import Optional

from pydantic import BaseModel

# This receives all the messages from Elixir.
# It's going to import all the other Python modules (LangChain, ChromaDB, etc)
# When we're going for scaling we are going to use elixir workers
# All send request to the same bridge but the bridge.py routes the right function based on the type field. No multiple Python processes.


class BridgeResponse(BaseModel):
    """
    Represents the responses that is generated by Python processes and sent back to Elixir
    """

    status: str
    response: Optional[str]
    error: Optional[str]


def handle_msg(msg: dict) -> BridgeResponse:
    """Handles incoming message from Elixir

    Args:
        msg (dict): Message received from Elixir

    Returns:
        dict: A response dictionary
    """
    type = msg.get("type")

    if type == "hello":
        count = msg.get("count", 0)
        return BridgeResponse(status="ok", response=f"hello from python {count}")

    else:
        return BridgeResponse(status="error", error=f"Unknown message type: {type}")


for line in sys.stdin:
    msg = json.loads(line)
    response = handle_msg(msg)
    response["_id"] = msg.get("_id")
    print(json.dumps(response))
    sys.stdout.flush()
